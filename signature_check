#!/usr/bin/env bash
# macos-scripts/signature_check

# signature_check
#  Check for applications which are not code signed
#  Check for apps that are notarized
#  Execution time approximately 5 to 10 minutes

set -o pipefail
# -o pipefail force pipelines to fail on first non-zero status code


IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###
tput sgr0; 
# reset colors

readonly RESET=$(tput sgr0)

readonly RED=$(tput setaf 1)
readonly GREEN=$(tput setaf 64)
### END Colours ###


function ctrl_c {
  echo -e "\\n[❌] ${USER} has chosen to quit!"
  exit 1
}


function xcode_check {

  if xcode-select -p >/dev/null 2>&1; then 
    xcode_status="True"
  else
    xcode_status="False"
    echo "Can't check Notarisation status - Xcode Command Line Tools not installed"
  fi
}


function get_applications {

  echo "Getting list of applications..."

  while IFS=$'\n' read -r app; do 
    apps+=("${app}"); 
  done < <(system_profiler SPApplicationsDataType \
            | grep "Location: " \
            | awk -F ': ' '{print $2}')
}


function check_applications {

  for app in "${apps[@]}"; do

    if ! output="$(codesign --verify --deep --strict "${app}" 2>&1)"; then
      # Call codesign on every $app in $apps and save stdout to $output
      
      if echo "${output}" | grep -q "is not signed at all"; then
        not_signed+=("${app}");

      elif echo "${output}" | grep -q "resource fork, Finder information, or similar detritus not allowed"; then
        xa_resource_fork_finder_information+=("${app}");
        # xa = extended attribute
        # https://developer.apple.com/library/archive/qa/qa1940/_index.html

      elif echo "${output}" | grep -q "a sealed resource is missing or invalid"; then
        broken_signature+=("${app}");
        # https://developer.apple.com/library/archive/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919-CH1-TNTAG20
      elif echo "${output}" | grep -q "CSSMERR_TP_CERT_REVOKED"; then
        signed_with_revoked_certificate+=("${app}");
      fi
    
    else [[ "${xcode_status}" == "True" ]];
      if "${stapler_path}" validate "${app}" >/dev/null 2>&1; then 
        notarized+=("${app}");
      fi
    fi
done
}


function main {

  trap ctrl_c SIGINT
  # Detect and react to the user hitting CTRL + C

  declare -a apps
  declare -a notarized
  declare -a not_signed
  declare -a signed_with_revoked_certificate
  declare -a xa_resource_fork_finder_information
  declare -a broken_signature
  readonly stapler_path="/usr/bin/stapler"

  xcode_check
  get_applications
  check_applications

  if [ ${#notarized[@]} -gt 0 ]; then
     echo "${GREEN}Notarized (${#notarized[@]}):${RESET}" 
    for app in "${notarized[@]}"; do
      echo "  ${app}"
    done
    echo
  fi

  if [ ${#not_signed[@]} -gt 0 ]; then
     echo "${RED}Not Signed (${#not_signed[@]}):${RESET}" 
    for app in "${not_signed[@]}"; do
      echo "  ${app}"
    done
    echo
  fi

  if [ ${#signed_with_revoked_certificate[@]} -gt 0 ]; then
    echo "${RED}Signed with untrusted certificate (${#signed_with_revoked_certificate[@]}):${RESET}" 
    for app in "${signed_with_revoked_certificate[@]}"; do
      echo "  ${app}"
    done
    echo
  fi

  if [ ${#xa_resource_fork_finder_information[@]} -gt 0 ]; then
    echo "${RED}Resource Fork or Finder Information: (${#xa_resource_fork_finder_information[@]}):${RESET}" 
    for app in "${xa_resource_fork_finder_information[@]}"; do
      echo "  ${app}"
    done
  fi

  if [ ${#broken_signature[@]} -gt 0 ]; then
    echo "${RED}Broken Signature: (${#broken_signature[@]}):${RESET}" 
    for app in "${broken_signature[@]}"; do
      echo "  ${app}"
    done
  fi
}

main "$@"
