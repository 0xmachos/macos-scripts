#!/usr/bin/env bash
# macos-scripts/signature_check

# signature_check
#  Check for applications which are not code signed
#  Check for apps that are notarized
#  Execution time approximately 5 to 10 minutes

set -o pipefail
# -o pipefail force pipelines to fail on first non-zero status code


IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###
tput sgr0; 
# reset colors

readonly RESET=$(tput sgr0)
readonly BOLD=$(tput bold)

readonly RED=$(tput setaf 1)
readonly GREEN=$(tput setaf 64)
### END Colours ###


function ctrl_c {
  echo -e "\\n[❌] ${USER} has chosen to quit!"
  exit 1
}


function xcode_check {

  if xcode-select -p >/dev/null 2>&1; then 
    xcode_status="True"
  else
    xcode_status="False"
  fi
}


function version_check {

current_macos_version="$(sw_vers -productVersion | awk -F '.' '{print $1 "." $2}')";

  if [ "${current_macos_version}" = "10.14" ]; then
    stapler_path="/Library/Developer/CommandLineTools/usr/bin/stapler"

  elif [[ "${current_macos_version}" = "10.15" ]]; then
    stapler_path="/usr/bin/stapler"
  fi
}


function get_applications {

  while IFS=$'\n' read -r app; do 
    apps+=("${app}"); 
  done < <(system_profiler SPApplicationsDataType \
            | grep "Location: " \
            | awk -F ': ' '{print $2}')
}


function check_applications {

  for app in "${apps[@]}"; do
    
    if ! output="$(pkgutil --check-signature "${app}")"; then 
      
      if echo "${output}" | grep -q "no signature"; then
        not_signed+=("${app}");

      elif echo "${output}" | grep -q "untrusted certificate"; then
        signed_with_untrusted_certificate+=("${app}");

      elif echo "${output}" | grep -q "invalid"; then
        broken_signature+=("${app}");
      fi
    
    elif [[ "${xcode_check}" = "True" ]]; then
      if "${stapler_path}" validate "${app}" >/dev/null 2>&1; then
        notarized+=("${app}");
      fi
    fi
done
}


function main {

  trap ctrl_c SIGINT
  # Detect and react to the user hitting CTRL + C

  declare -a apps
  declare -a notarized
  declare -a not_signed
  declare -a signed_with_untrusted_certificate
  declare -a broken_signature

  version_check
  xcode_check
  if [[ "${xcode_status}" = "False" ]]; then
    echo "Can't check Notarisation status - Xcode Command Line Tools not installed"
  fi
  get_applications
  check_applications


  if [ ${#notarized[@]} -gt 0 ]; then
     echo "${GREEN}Notarized (${#notarized[@]}):${RESET}" 
    for app in "${notarized[@]}"; do
      echo "  ${app}"
    done
    echo
  fi


  if [ ${#not_signed[@]} -gt 0 ]; then
     echo "${RED}Not Signed (${#not_signed[@]}):${RESET}" 
    for app in "${not_signed[@]}"; do
      echo "  ${app}"
    done
    echo
  fi


  if [ ${#signed_with_untrusted_certificate[@]} -gt 0 ]; then
    echo "${RED}Signed with untrusted certificate (${#signed_with_untrusted_certificate[@]}):${RESET}" 
    for app in "${signed_with_untrusted_certificate[@]}"; do
      echo "  ${app}"
    done
    echo
  fi


  if [ ${#broken_signature[@]} -gt 0 ]; then
    echo "${RED}Broken Signature: (${#broken_signature[@]}):${RESET}" 
    for app in "${broken_signature[@]}"; do
      echo "  ${app}"
    done
  fi
}

main "$@"
