#!/usr/bin/env zsh
# macos-scripts/c0design

# c0design
#   Wrapper for codesign, spctl & stapler
#   See Howard Oakley's (@howardnoakley) work:
#     https://eclecticlight.co/2019/05/31/can-you-tell-whether-code-has-been-notarized/
#     https://eclecticlight.co/2020/10/30/code-signatures-2-how-to-check-them/

set -uo pipefail
# -o pipefail force pipelines to fail on first non-zero status code
# -u prevent using undefined variables

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###
tput sgr0; 
# reset colors

readonly RESET=$(tput sgr0)

readonly RED=$(tput setaf 1)
readonly YELLOW=$(tput setaf 3)
readonly GREEN=$(tput setaf 64)
### END Colours ###


function usage {
  echo 
  echo "  Wrapper for codesign, spctl & stapler"
  echo "  Usage: ./c0design {usage | list | verify \$application_path | thirdparty}"
  echo

  echo "  list        List all non system applications (excludes Xcode & Safari)"
  echo "  verify      Check codesigning and notarisation of application at \$application_path"
  echo "              Equivalent of codesign --verify --deep --strict && spctl --assess --type exec "
  echo "  thirdparty  Check codesigning and notarisation of all non system applications"
  echo
  
  exit 0
}


### Utility Functions ###
# ctrl_c

function ctrl_c {
  echo -e "\\n[‚ùå] ${USER} has chosen to quit!"
  exit 1
}


function check_spctl_status {
  # spctl_status
  #   Check if SecAssessment subsystem is enabled
  #   If it is not enabled all notarisation checks will fail
  #   If spctl --master-disable has been executed spctl --status 
  #     will return 1

  if /usr/sbin/spctl --status >/dev/null 2&>1; then
    return 0
  else
    echo "[‚ö†Ô∏è ] SecAssessment subsystem has been disabled, ${RED}all notarisation checks will fail${RESET}"
    return 1
  fi
}

### END Utility Functions ###


function get_applications {
  # get_applications
  #   Get list of all applications on system via system_profiler
  #   Ignore system applications, produces array of non system apps
  
  while IFS=$'\n' read -r app; do
   
    if [[ "${app}" =~ /System/ ]]; then
      continue
      # Skip everything in /System/Applications/ and /System/Library/
      #   since they can't be third party apps
    elif [[ "${app}" =~ Xcode.app ]]; then
      continue
      # Skip Xcode because it takes ages to run codesign on it
    elif [[ "${app}" =~ Safari.app ]]; then
      continue
      # Skip Safari because it is a system application
    fi
    
    apps+=("${app}");
    # e.g. Adds "/Applications/1Password 7.app" to apps array

  done < <(system_profiler SPApplicationsDataType \
            | grep "Location: " \
            | awk -F ': ' '{print $2}')
}



function verify_app_signature {
  # verify_app_signature
  #   Verify that app at $application_path is correctly code signed
  #   Save codesign output in $codesign_output for priting errors

  declare -r application_path=${1:?application_path not passed to verify_app_signature}

  if codesign_output="$(/usr/bin/codesign --verify --deep --strict "${application_path}" 2>&1)"; then
    # codesign sends all output to stderr, redirect it to std out
    return 0
  elif [[ "${codesign_output}" =~ No\ such\ file\ or\ directory ]]; then
    echo "${application_path}: No such file or directory"
    exit 1
  else
    return 1
  fi
}


function check_notarsied {
  # check_notarsied
  #   Check if app is allowed to be executed under current system policy
  #   On systems with default settings this will check if app is notarised
  #   If SecAssessment has been disabled spctl notarised checks will fail
  #   If system has SecAssessment disabled (e.g. spctl --master-disable has been executed)
  #     you can execute codesign --test-requirement="=notarized" --verify to check notarisation

  declare -r application_path=${1:?application_path not passed to check_notarsied}

  if /usr/sbin/spctl --assess --type exec "${application_path}" >/dev/null 2>&1; then
    # Check if system policy allows execution of this code aka Notarised
    return 0 
  else
    return 1
  fi
}


function check_stapled_notarisation_ticket {
  # check_stapled_notarisation_ticket
  #   Check if the application at $application_path has a locally stapled
  #     notarisation ticket
  #   Not having a locally staped ticket is NOT a security issue, Apple can
  #     hold the ticket on their servers with macOS reaching out to Apple to
  #     validate the app/ticket.
  #   See  Howard Oakley's (@howardnoakley) tweet:
  #     https://twitter.com/howardnoakley/status/1369328846466650120

  declare -r application_path=${1:?application_path not passed to check_stapled_notarisation_ticket}

  if /usr/bin/stapler validate "${application_path}" >/dev/null 2>&1; then
    # Check if app has a notarisation ticket stapled to it
    return 0
  else
    return 1
  fi
}

function check_if_app_from_app_store {
  # check_if_app_from_app_store
  #   Checks if app is from Mac App Store
  #     or from outside App Store based on intermediate certificate used
  #     to sign the leaf certificate
  #   Could also use 
  #     mdls "${application_path}" -name kMDItemAppStoreHasReceipt

  declare -r application_path=${1:?application_path not passed to check_stapled_notarisation_ticket}
  codesign_output=$(/usr/bin/codesign --display --verbose=2 "${application_path}" 2>&1)

  if echo "${codesign_output}" | grep -q "Authority=Apple Mac OS Application Signing"; then
    return 0
    # echo "Mac App Store"
  elif echo "${codesign_output}" | grep -q "Authority=Developer ID Certification Authority"; then
    return 1
    # echo "Developer App"
  fi
}


function verify {
  # verify
  #   Use the above helper functions to check application
  #     1. Properly signed
  #     2. Notarised
  #     3. Locally stapled notarisation ticket
  #     4. From Mac App Store or Developer ID App
  #   echo to command line based on above criteria

  declare -r application_path=${1:?application_path not passed to verify}

  if verify_app_signature "${application_path}"; then
    
    if check_notarsied "${application_path}"; then
      
      if check_stapled_notarisation_ticket "${application_path}"; then
        echo "$(/usr/bin/basename "${application_path}") ${GREEN}signed, properly verified & notarised (stapled ticket)${RESET}"
        # Wording from man page is "all codes verified properly as requested"
      else
        
        if check_if_app_from_app_store "${application_path}"; then
          echo "$(/usr/bin/basename "${application_path}") ${GREEN}signed, properly verified & notarised${RESET} (App Store App) ${YELLOW}(no stapled ticket)${RESET}"
          # Apps from the AppStore never have stapled tickets
        else
          echo "$(/usr/bin/basename "${application_path}") ${GREEN}signed, properly verified & notarised${RESET} (Developer ID App) ${YELLOW}(no stapled ticket)${RESET}"
          # Developer ID apps can have stapled tickets, not a requiremnt though
        fi
      fi
    
    else
      echo "$(/usr/bin/basename "${application_path}") ${GREEN}signed and properly verified${RESET} but ${RED}not notarised${RESET}"
    fi

  else
    codesign_error_message=$(echo "${codesign_output}" | head -n 1 | awk -F ':' '{print $2}')
    # head -n 1 removes the "In architecture" output which indicates in a Fat/Universal binary which
    #   specific binary has failed code signing checks. 
    # Output is either x86_64 or arm64e
    # Currently don't care about which binary has fialed code signing checks just that one or the other has
    echo "$(/usr/bin/basename "${application_path}") ${RED}${codesign_error_message}${RESET}"
    return 1
  fi
}


function main {

  trap ctrl_c SIGINT
  # Detect and react to the user hitting CTRL + C

  declare -r arg=${1:-"usage"}
  declare -r application_path=${2:-null}
  # Set application_path to "null" if argv[2] is null or unset
  # This is a probably a dirty hack that needs a proper solution
  # Should be able to use parameter expansion but bug when using ${2+} which 
  #   causes application_path to be set to empty even when argv[2] 
  #   is not empty. i.e. with ${2+} ./c0design verify aaa thinks argv[2] empt

  declare -a apps

  case "${arg}" in

    usage|help|-h|--help|ü§∑‚Äç‚ôÇÔ∏è|ü§∑‚Äç‚ôÄÔ∏è|"¬Ø\_(„ÉÑ)_/¬Ø")
      usage
      ;;

    list|-l|--list)
      get_applications

      for app in "${apps[@]}"; do
        echo "${app}"
      done
      ;;

    verify|-v|--verify)
      check_spctl_status
      
      if [[ "${application_path}" == "null" ]]; then
        usage
      fi
      verify "${application_path}"
      ;;

    thirdparty|-tp|--third-party)
      check_spctl_status
      
      get_applications

      for app in "${apps[@]}"; do
        verify "${app}"
      done 
      ;;

    *)
      usage
      ;;
  esac

}

main "$@"
